# 说明

## 运行
```
yarn
yarn dev
```

> 1. 通过`nodemon`监听文件变化，写完会更新`server`，但`client`不会，要刷新
> 2. 可以在`vscode`里直接`f5`启动`server`断点调试



## 上传

1. 单个小文件，`2m`以内的，就直接上传，不需要搞花花
2. 多个小文件一起，那看情况。
   1. 如果能确定都是些 `kb`级别，而且数量并不是特别多，比如`10`个左右，那可以合成一个 `FormData`，一次上传就行。就当是一个小文件。
   2. 如果是`2、3m`左右的，可设置队列，挨个上传。这跟单个小文件上传类似。
   3. 如果是很多很多个文件，几十上百个，直接拒绝这种需求。【需求不合理】
3. 单个大文件，现在的网速，`10m`左右的，也可以选择直接上传，影响不大。
4. 单个的大文件，`100m` 以上了，就要分片传了。
5. 多个大文件，就每个大文件自己上传。并不看作是一起上传。


### 分片上传分几步：

1. 通过 `input` 获取 `file` 对象
2. 通过 `FileReader` 读取文件，然后计算文件的 `hash` 值。
  > 计算 `hash` ，可以用 `spark-md5`
  >  1. 可以读完整文件之后一次性计算，适用于稍小的文件
  >  2. 对于大的文件，可以分成几部分一点一点读进来，让 `spark` 去算。
3. 前端请求 `/upload/check`, 带上分片信息，文件信息，后端去查询后告诉前端，该文件是否已经上传成功。
   1. 如果返回成功，前端直接弹消息提示成功
   2. 如果不成功，就告诉前端该文件已经成功上传过哪些片
4. 开始上传
   1. 根据约定的分片策略，限总片数量/限单片大小，构建分片数据
   2. 通过 `slice` 方法可以截取出对应片的 binary data
   3. 通过 `xhr` 发送到后端。注意：如果是已经成功上传过的片要略过。
   4. 一次 `send` 成功后，`complete` 方法里检查一下是否还有需要传的片了。
      1. 如果没了，就发送 `/upload/merge` 通知后台合并文件.
      2. 如果还有，继续 `xhr` 发送对应的片
   5. 如果 `send` 是失败的，要把对应的片信息记录下来，可以放入一个失败队列里，在 `complete` 方法里也验证下失败队列有没有需要上传的。



### 分片同样会有问题：

1. 后台如果只将文件片段数据存内存里，那就会发生数据丢失或者暂时无法确定是否回收数据占用内存的问题。
2. 如果片收到后先落入磁盘实体，那最后合并时就又遇到了多片的磁盘IO问题。
   
所以整个分片吧，也不是那么完美。如果并不是那么严苛的要求时效性，那还是很有益处的。如果严苛的要求时效性，那这个问题几乎是无解的。

## 下载

1. 小文件下载，`2m` 以内的
   1. 可以直接浏览器下载。注意响应的 `content-disposition` 头
   2. 或者通过 `xhr` 获取文件的 `blob` 对象后，通过 `a` 标签下载.【这种方式就跟项目里其他的请求一样，可以由后台验证权限信息的】
2. 大文件下载
   1. 同样可以浏览器下载。这是最推荐的方式。因为浏览器下载可以续传呀。
   2. 通过设置 `range` 头，利用 `http` 的 `206` 状态码，获取文件的片。都下载成功后，利用 `ArrayBuffer` 和 `Uint8Array` 进行合并
  
```
xhr.setRequestHeader("range", `bytes=${chunk.start}-${chunk.end}`);
```

### 下载的一点说明：
   
文件的下载没什么特别的花花。

对于分片下载，文件的数据都是暂时存在内存里，这样会短时间增加网站整体的内存占用。有崩溃的可能。而且到此时，分片并不能保证续传。

当然也可以续传。已经传完的片可以记录到本地的 `indexed db` 中，然后最后合并保存。但同样避免不了一时的内存占用，并且使用了 `db` ，还会遇到很多 `db` 的问题。比如开两个窗口，都去下载，怎么避免这种问题。所以还是不建议这么做。

这些都没有使用浏览器下载来的方便和有效。浏览器下载可以本身就续传，特别有益于网络问题。

但浏览器下载就会遇到盗链的问题。一旦链接被获取，那就可以被任意下载。

> 所以对于下载，不管大文件还是小文件，也不管多少个文件，`最好的下载方式就是通过 api 换取有临时访问权限的 url，然后让浏览器去下载`





## 链接

[blob](https://zh.javascript.info/blob)

[koa](https://chenshenhai.github.io/koa2-note/note/upload/simple.html)

[node里用fs流传文件](https://www.cnblogs.com/tugenhua0707/p/10828869.html)

[indexed db](https://zh.javascript.info/indexeddb)

[indexed db api 2.0](https://www.w3.org/TR/IndexedDB-2/)

[indexed db api 3.0](https://www.w3.org/TR/IndexedDB/)