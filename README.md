# 说明

## 运行
```
yarn
yarn dev
```

> 1. 通过nodemon监听文件变化，写完会更新server，但client不会，要刷新
> 2. 可以在vscode里直接f5启动server断点调试


> 最好的下载方式就是通过 api 换取有临时权限的 url，然后让浏览器去下载


## 上传策略

1. 单个小文件，2m以内的，就直接上传，不需要搞花花
2. 多个小文件一起，那看情况。
   1. 如果能确定都是些 kb级别，而且数量并不是特别多，比如10个左右，那可以合成一个 FormData，一次上传就行。就当是一个小文件。
   2. 如果是2、3m左右的，可设置队列，挨个上传。这跟单个小文件上传类似。
   3. 如果是很多很多个文件，几十上百个，直接拒绝这种需求。【需求不合理】
3. 单个大文件，现在的网速，10m左右的，也可以选择直接上传，影响不大。
4. 单个的大文件，100m 以上了，就要分片传了。
5. 多个大文件，就每个大文件自己上传。并不看作是一起上传。


### 分片上传分几步：

1. 通过 input 获取 file 对象
2. 通过 FileReader 读取文件，然后计算文件的 hash 值。
  > 计算hash，可以用 spark-md5
  >  1. 可以读完整文件之后一次性计算，适用于稍小的文件
  >  2. 对于大的文件，可以分成几部分一点一点读进来，让 spark 去算。
3. 前端请求 /upload/check, 带上分片信息，文件信息，后端去查询后告诉前端，该文件是否已经上传成功。
   1. 如果返回成功，前端直接弹消息提示成功
   2. 如果不成功，就告诉前端该文件已经成功上传过哪些片
4. 开始上传
   1. 根据约定的分片策略，限总片数量/限单片大小，构建分片数据
   2. 通过 slice 方法可以截取出对应片的 binary data
   3. 通过 xhr 发送到后端。注意：如果是已经成功上传过的片要略过。
   4. 一次 send 成功后，complete方法里检查一下是否还有需要传的片了。
      1. 如果没了，就发送 /upload/merge 通知后台合并文件
      2. 如果还有，继续 xhr 发送对应的片
   5. 如果send 是失败的，要把对应的片信息记录下来，可以放入一个失败队列里，在complete方法里也验证下失败队列有没有需要上传的。


[blob](https://zh.javascript.info/blob)

[koa](https://chenshenhai.github.io/koa2-note/note/upload/simple.html)

[node里用fs流传文件](https://www.cnblogs.com/tugenhua0707/p/10828869.html)