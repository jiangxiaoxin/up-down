# 说明

## 运行
```
yarn
yarn dev
```

> 1. 通过nodemon监听文件变化，写完会更新server，但client不会，要刷新
> 2. 可以在vscode里直接f5启动server断点调试



## 上传

1. 单个小文件，2m以内的，就直接上传，不需要搞花花
2. 多个小文件一起，那看情况。
   1. 如果能确定都是些 kb级别，而且数量并不是特别多，比如10个左右，那可以合成一个 FormData，一次上传就行。就当是一个小文件。
   2. 如果是2、3m左右的，可设置队列，挨个上传。这跟单个小文件上传类似。
   3. 如果是很多很多个文件，几十上百个，直接拒绝这种需求。【需求不合理】
3. 单个大文件，现在的网速，10m左右的，也可以选择直接上传，影响不大。
4. 单个的大文件，100m 以上了，就要分片传了。
5. 多个大文件，就每个大文件自己上传。并不看作是一起上传。

## 下载

1. 小文件下载，2m以内的
   1. 可以直接浏览器下载。注意响应的 content-disposition 头
   2. 或者通过 xhr 获取文件的 blob 对象后，通过 a 标签下载
2. 大文件下载
   1. 同样可以浏览器下载。这都是最推荐的方式
   2. 通过设置 range 头，利用 http 的 206 状态码，获取文件的片。都下载成功后，利用 ArrayBuffer 和 Uint8Array 进行合并
  
```
xhr.setRequestHeader("range", `bytes=${chunk.start}-${chunk.end}`);
```

### 一点说明：
   
文件的下载没什么特别的花花。

对于分片下载，文件的数据都是暂时存在内存里，这样会短时间增加网站整体的内存占用。有崩溃的可能。而且到此时，分片并不能保证续传。

当然也可以续传。已经传完的片可以记录到本地的 indexed db中，然后最后合并保存。但同样避免不了一时的内存占用，并且使用了 db，还会遇到很多 db的问题。比如开两个窗口，都去下载，怎么避免这种问题。所以还是不建议这么做。

这些都没有使用浏览器下载来的方便和有效。浏览器下载可以本身就续传，特别有益于网络问题。

但浏览器下载就会遇到盗链的问题。一旦链接被获取，那就可以被任意下载。

> 所以对于下载，不管大文件还是小文件，也不管多少个文件，最好的下载方式就是通过 api 换取有临时访问权限的 url，然后让浏览器去下载


### 分片上传分几步：

1. 通过 input 获取 file 对象
2. 通过 FileReader 读取文件，然后计算文件的 hash 值。
  > 计算hash，可以用 spark-md5
  >  1. 可以读完整文件之后一次性计算，适用于稍小的文件
  >  2. 对于大的文件，可以分成几部分一点一点读进来，让 spark 去算。
3. 前端请求 /upload/check, 带上分片信息，文件信息，后端去查询后告诉前端，该文件是否已经上传成功。
   1. 如果返回成功，前端直接弹消息提示成功
   2. 如果不成功，就告诉前端该文件已经成功上传过哪些片
4. 开始上传
   1. 根据约定的分片策略，限总片数量/限单片大小，构建分片数据
   2. 通过 slice 方法可以截取出对应片的 binary data
   3. 通过 xhr 发送到后端。注意：如果是已经成功上传过的片要略过。
   4. 一次 send 成功后，complete方法里检查一下是否还有需要传的片了。
      1. 如果没了，就发送 /upload/merge 通知后台合并文件
      2. 如果还有，继续 xhr 发送对应的片
   5. 如果send 是失败的，要把对应的片信息记录下来，可以放入一个失败队列里，在complete方法里也验证下失败队列有没有需要上传的。


## 链接

[blob](https://zh.javascript.info/blob)

[koa](https://chenshenhai.github.io/koa2-note/note/upload/simple.html)

[node里用fs流传文件](https://www.cnblogs.com/tugenhua0707/p/10828869.html)

[indexed db](https://zh.javascript.info/indexeddb)

[indexed db api 2.0](https://www.w3.org/TR/IndexedDB-2/)

[indexed db api 3.0](https://www.w3.org/TR/IndexedDB/)